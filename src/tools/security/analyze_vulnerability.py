"""Tool #24: Analyze Vulnerability - Uses AI to analyze security vulnerabilities."""

from typing import Dict, Any
from src.integrations.client_factory import get_gemini_client
from src.config import settings
from src.utils.logging import get_logger
import time
import json

logger = get_logger(__name__)


class AnalyzeVulnerabilityTool:
    """Tool for analyzing security vulnerabilities using AI."""
    
    def __init__(self):
        self.name = "analyze_vulnerability"
        self.description = "Analyzes security vulnerabilities using Gemini AI"
    
    async def execute(self, vulnerability_data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Analyze vulnerability using AI.
        
        Args:
            vulnerability_data: Vulnerability information to analyze
            
        Returns:
            Dict containing vulnerability analysis and recommendations
        """
        start_time = time.time()
        
        try:
            logger.info("Analyzing vulnerability", 
                       vulnerability_id=vulnerability_data.get("id"),
                       severity=vulnerability_data.get("severity"))
            
            # Get Gemini client
            gemini_client = get_gemini_client()
            
            # Use Gemini AI to analyze the vulnerability
            analysis = await gemini_client.analyze_security_vulnerability(vulnerability_data)
            
            if not analysis:
                return {
                    "success": False,
                    "error": "Failed to get AI analysis",
                    "duration_ms": int((time.time() - start_time) * 1000)
                }
            
            # Enhance analysis with additional context
            enhanced_analysis = self._enhance_analysis(analysis, vulnerability_data)
            
            duration_ms = int((time.time() - start_time) * 1000)
            
            logger.info("Vulnerability analysis completed", 
                       vulnerability_id=vulnerability_data.get("id"),
                       risk_level=enhanced_analysis.get("risk_assessment", {}).get("level"),
                       duration_ms=duration_ms)
            
            return {
                "success": True,
                "vulnerability_id": vulnerability_data.get("id"),
                "analysis": enhanced_analysis,
                "duration_ms": duration_ms
            }
            
        except Exception as e:
            duration_ms = int((time.time() - start_time) * 1000)
            logger.error("Error analyzing vulnerability", 
                        error=str(e), duration_ms=duration_ms)
            
            return {
                "success": False,
                "error": str(e),
                "duration_ms": duration_ms
            }
    
    def _enhance_analysis(self, ai_analysis: Dict[str, Any], 
                         vulnerability_data: Dict[str, Any]) -> Dict[str, Any]:
        """Enhance AI analysis with additional context."""
        
        enhanced = ai_analysis.copy()
        
        # Add vulnerability metadata
        enhanced["vulnerability_metadata"] = {
            "id": vulnerability_data.get("id"),
            "type": vulnerability_data.get("type"),
            "package": vulnerability_data.get("package"),
            "severity": vulnerability_data.get("severity"),
            "cve_id": vulnerability_data.get("cve_id"),
            "created_at": vulnerability_data.get("created_at"),
            "state": vulnerability_data.get("state")
        }
        
        # Add priority scoring
        enhanced["priority_score"] = self._calculate_priority_score(vulnerability_data, ai_analysis)
        
        # Add timeline recommendations
        enhanced["timeline"] = self._generate_timeline_recommendations(vulnerability_data, ai_analysis)
        
        # Add automation recommendations
        enhanced["automation_recommendations"] = self._generate_automation_recommendations(vulnerability_data, ai_analysis)
        
        return enhanced
    
    def _calculate_priority_score(self, vulnerability_data: Dict[str, Any], 
                                ai_analysis: Dict[str, Any]) -> Dict[str, Any]:
        """Calculate priority score for the vulnerability."""
        
        base_score = 0
        
        # Severity scoring
        severity = vulnerability_data.get("severity", "").lower()
        severity_scores = {
            "critical": 100,
            "high": 75,
            "medium": 50,
            "low": 25
        }
        base_score += severity_scores.get(severity, 0)
        
        # Exploitability scoring (from AI analysis)
        exploitability = ai_analysis.get("exploitability", {}).get("level", "").lower()
        exploit_scores = {
            "high": 30,
            "medium": 20,
            "low": 10
        }
        base_score += exploit_scores.get(exploitability, 0)
        
        # Impact scoring (from AI analysis)
        impact = ai_analysis.get("impact", {}).get("level", "").lower()
        impact_scores = {
            "high": 20,
            "medium": 15,
            "low": 5
        }
        base_score += impact_scores.get(impact, 0)
        
        # Determine priority level
        if base_score >= 120:
            priority_level = "critical"
        elif base_score >= 90:
            priority_level = "high"
        elif base_score >= 60:
            priority_level = "medium"
        else:
            priority_level = "low"
        
        return {
            "score": base_score,
            "level": priority_level,
            "max_score": 150
        }
    
    def _generate_timeline_recommendations(self, vulnerability_data: Dict[str, Any], 
                                         ai_analysis: Dict[str, Any]) -> Dict[str, Any]:
        """Generate timeline recommendations for fixing the vulnerability."""
        
        severity = vulnerability_data.get("severity", "").lower()
        
        # Base timelines by severity
        timeline_map = {
            "critical": {
                "immediate_action": "Within 24 hours",
                "patch_deployment": "Within 48 hours",
                "verification": "Within 72 hours"
            },
            "high": {
                "immediate_action": "Within 3 days",
                "patch_deployment": "Within 1 week",
                "verification": "Within 10 days"
            },
            "medium": {
                "immediate_action": "Within 1 week",
                "patch_deployment": "Within 2 weeks",
                "verification": "Within 3 weeks"
            },
            "low": {
                "immediate_action": "Within 2 weeks",
                "patch_deployment": "Within 1 month",
                "verification": "Within 6 weeks"
            }
        }
        
        return timeline_map.get(severity, timeline_map["medium"])
    
    def _generate_automation_recommendations(self, vulnerability_data: Dict[str, Any], 
                                           ai_analysis: Dict[str, Any]) -> Dict[str, Any]:
        """Generate automation recommendations."""
        
        recommendations = {
            "can_auto_fix": False,
            "auto_fix_confidence": 0,
            "recommended_actions": [],
            "manual_review_required": True
        }
        
        # Check if it's a dependency update
        if vulnerability_data.get("type") == "dependabot" and vulnerability_data.get("first_patched_version"):
            recommendations["can_auto_fix"] = True
            recommendations["auto_fix_confidence"] = 85
            recommendations["recommended_actions"].append("Automated dependency update")
            recommendations["manual_review_required"] = False
        
        # Add monitoring recommendations
        recommendations["monitoring"] = {
            "enable_alerts": True,
            "scan_frequency": "daily" if vulnerability_data.get("severity") in ["critical", "high"] else "weekly",
            "notification_channels": ["email", "slack"]
        }
        
        return recommendations


# Global tool instance
analyze_vulnerability_tool = AnalyzeVulnerabilityTool()
